NCF:神经协同过滤框架，**用神经网络学习用户和物品的交互。**
步骤：在pytorch中定义一个神经网络模型，输入包括用户嵌入、物品嵌入，可能还有**用户ID和物品ID**等特征。
> 用户ID和物品ID为什么可以作为特征输入模型？
> sentence-BERT作为一种句子嵌入的方法，是否适合用在评分预测任务上，使用BERT和使用sentence-bert相比有什么不同之处？
- sentence-bert可以作为评分预测任务的词嵌入。是否适合用在评分预测任务上，要看具体的实验表现如何。

##### 训练集需要随机打乱数据，验证集和测试集不需要打乱数据，why？
- 训练集打乱防止模型学习数据顺序偏差，提升泛化能力。训练数据往往按某种顺序存储（时间、类别），如果不打乱，模型可能学到数据的顺序模式，导致过拟合或训练不充分。打乱能保证每个批次样本分布更均匀，避免训练过程中的偏差，加速收敛。
- 验证集用于调参，测试集用于最后评估，要求数据分布和顺序一致，保证评估的公平性和可重复性。打乱验证或者测试集可能导致结果波动，影响模型性能的准确判断。

基于用户id，物品id和评分三列数据，可以使用比如BiasSVD的矩阵分解方法来提取用户隐向量和物品隐向量。与此同时，针对于评论文本，我们则是另外一套的处理方法，按照用户和物品划分为用户评论集和商品评论集，在用户评论集中，将某一用户对所有商品的评论都拼接在一起，在商品评论集中，将某一商品的所有评论都拼接在一起。这样我们就可以使用一些文本处理方法，提取出每一位用户和商品的评论文本的深度向量。这个嵌入过程可以用sentence-bert来提取么？最后，我们希望把矩阵分解得到的隐向量和词嵌入得到的深度向量进行综合，也就是使用评分和评论来构建一个评分预测的模型。



**dataloader是干嘛用的，我能把我的数据加载用dataloader来实现么？**
- 可以
- dataloader是pytorch中用于批量、打乱、多线程加载数据的工具。
- 你需要先实现一个**Dataset类**来封装你的数据。
- 然后用dataloader来加载该dataset，方便批量迭代数据。
- 可以极大简化数据准备工作，提升训练效率。



#### 模型输入：
##### 用户隐向量，物品隐向量（BiasSVD方法）
- 隐向量：Surprise库确实能够输出用户和产品的隐向量，但需要通过访问模型训练后的内部属性来实现。例如SVD算法训练之后，模型对象中有pu（用户隐向量矩阵）和qi（物品隐向量矩阵）属性，可以用来提取用户和产品的隐向量。

###### 用户深度向量，物品深度向量（词嵌入方法）
  - 将每个用户的所有评论拼接成一个长字符串，使用sentence-bert(或其他模型)生成一个**384维**的嵌入向量。物品评论同理。
  - 使用sentence-bert作出的嵌入，是直接的用户特征和商品特征么，需要使用其他LSTM或者CNN进行进一步处理么？
用户ID，物品ID是否可作为特征输入？
情感特征（粗粒度情感特征和细粒度情感特征）是否可以作为特征输入？

#### 混合向量的方法：直接拼接or其他方法
- 将矩阵分解得到的用户隐向量和商品隐向量与文本嵌入得到的用户深度向量和商品深度向量进行拼接。
  - 拼接的时候需要把隐向量转化为tensor么？：需要，要么是都是tensor，要么都是numpy数组。
  - 用户隐向量维度为latent_dim，文本嵌入的维度是384，则新向量是[用户隐向量，拥物深度向量]，维度是lantent_dim+384.
  - 同样处理商品向量。
- **其他方法**：加权求和，设定一个学习权重（w）结合两种嵌入。混合嵌入向量 = w*用户隐向量 + (1-w)*用户深度向量

#### 评分预测：神经网络or其他？
- 输入：拼接后的用户和商品向量
- 模型：神经网络（模型待定）
- 输出：预测评分




**下午继续研读上午写的这些，解决遗留下来的问题，然后再出发。**
**把生成的tensor保存为pickle文件的必要性**
把用户深度向量和物品深度向量都保存为pickle文件，目的是什么呀？为什么不在上下文内存中直接使用呢？
1. 避免重复计算：生成深度向量通常计算开销比较大，保存为pickle文件后，下次可以直接加载，节省重新计算的时间和资源。
2. 数据持久化：避免每次都从头处理数据。
3. 保存为pickle文件之后，可以方便在不同机器间进行传递。



## 使用SVD来提取用户和物品的隐向量。
在训练阶段，只会生成训练集内用户和物品的隐向量，不会生成所有用户和物品的隐向量。
对于训练集中未出现的用户和商品，这属于冷启动问题，模型没有对应隐向量，预测时通常采用默认策略（如全局平均，偏置项等）进行估计。



### 划分训练集、测试集到底应该在那个位置进行？是一开始就划分，还是在完成所有嵌入之后再进行划分。


### 是否需要为冷启动用户创建默认的隐向量以及深度特征向量。
冷启动用户这里指的是测试集里出现的用户或商品，但是训练集里没有出现的用户和商品。

### __getitem__方法的作用
Pytorch的__getitem__方法定义了如何**根据索引获取单个样本数据。**
- 当idx = 0时，self.batch_data[idx]会返回第一个元组，元组里的user_id和item_id作为索引提取**预先生成**的嵌入向量。

### __getitem__返回的数据和后续的dataloader有什么关系呢？
- Dataloader通过__getitem__方法批量获取数据，并且实现：多线程加载（num_workers参数），数据打乱(shuffle=True)，批次生成（batch_size参数）。

### __len__和__getitem__的关系
- __len__ 返回数据集大小（len(batch_data)），定义索引上限；__getitem__(idx) 根据索引返回单个样本的数据。


   
